<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - node material</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="three.js"></script>

		<script src="Detector.js"></script>
		<script src="stats.min.js"></script>

		<script>
		
// ------------------------------------------------------------

THREE.NodeMaterial = function( vertex, fragment ) {
	
	THREE.ShaderMaterial.call( this );
	
	this.vertex = vertex || new THREE.NodeGL( new THREE.NodeGLPosition() );
	this.fragment = fragment || new THREE.NodeGL( new THREE.NodeColor( 0xFF0000 ) );
	
};

THREE.NodeMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.NodeMaterial.prototype.constructor = THREE.NodeMaterial;

THREE.NodeMaterial.Type = {
	t : 'sampler2D',
	i : 'int',
	fv1 : 'float',
	c : 'vec3',
	v2 : 'vec2',
	v3 : 'vec3',
	v4 : 'vec4'
};

THREE.NodeMaterial.GetShortcuts = function( prop, name ) {
	
	return {
		get: function () { return this[prop][name]; },
		set: function ( val ) { this[prop][name] = val; }
	};

};

THREE.NodeMaterial.Shortcuts = function( proto, prop, list ) {
	
	var shortcuts = {};
	
	for(var i = 0; i < list.length; ++i) {
		
		var name = list[i];
		
		shortcuts[name] =  this.GetShortcuts( prop, name );
	
	}
	
	Object.defineProperties( proto, shortcuts );

};

THREE.NodeMaterial.prototype.build = function() {
	
	var vertex, fragment;
	
	this.extensions = {};
	this.defines = {};
	this.uniforms = {}; 
	
	this.variables = {
		vUv : { type : 'v2' },
		vUv2 : { type : 'v2' },
		uv : { type : 'v2' },
		uv2 : { type : 'v2' },
		vNormal : { type : 'v3' },
		normal : { type : 'v3' },
		transformed : { type : 'v3' },
		reflectVec : { type : 'v3' },
		reflectCoord : { type : 'v3' },
		refractVec : { type : 'v3' },
		refractCoord : { type : 'v3' }
	};
	
	this.nodeData = {};	
	
	this.vertexUniform = [];
	this.fragmentUniform = [];
	
	this.vertexTemps = [];
	this.fragmentTemps = [];
	
	this.uniformList = [];
	
	this.needsUv = false;
	this.needsUv2 = false;
	this.needsNormal = false;
	this.needsTangent = false;
	this.needsColor = false;
	this.needsLight = false;
	
	this.vertexPars = '';
	this.fragmentPars = '';
	
	this.vertexCode = '';
	this.fragmentCode = '';
	
	vertex = this.vertex.generate( this, 'vertex', 'v4' );
	fragment = this.fragment.generate( this, 'fragment', 'v4' );
	
	if (this.needsUv) {
		
		this.addVertexPars( 'varying vec2 vUv;' );
		this.addFragmentPars( 'varying vec2 vUv;' );
		
		this.addVertexCode( 'vUv = uv;' );
		
	}
	
	if (this.needsUv2) {
		
		this.addVertexPars( 'varying vec2 vUv2; attribute vec2 uv2;' );
		this.addFragmentPars( 'varying vec2 vUv2;' );
		
		this.addVertexCode( 'vUv2 = uv2;' );
		
	}
	
	if (this.needsColor) {

		this.addVertexPars( 'varying vec4 vColor; attribute vec4 color;' );
		this.addFragmentPars( 'varying vec4 vColor;' );
		
		this.addVertexCode( 'vColor = color;' );
		
	}
	
	this.lights = this.needsLight;
	
	this.vertexShader = [
		this.vertexPars,
		this.getCodePars( this.vertexUniform, 'uniform' ),
		'void main(){',
		this.getCodePars( this.vertexTemps ),
		this.vertexCode,
		vertex,
		'}'
	].join( "\n" );
	
	this.fragmentShader = [
		this.fragmentPars,
		this.getCodePars( this.fragmentUniform, 'uniform' ),
		'void main(){',
		this.getCodePars( this.fragmentTemps ),
		this.fragmentCode,
		fragment,
		'}'
	].join( "\n" );
	
	this.needsUpdate = true;
	
	return this;
};

THREE.NodeMaterial.prototype.define = function(name) {

	this.defines[name] = true;

};

THREE.NodeMaterial.prototype.extension = function(name) {

	this.extensions[name] = 'enable';

};

THREE.NodeMaterial.prototype.mergeUniform = function( uniforms ) {
	
	for (var name in uniforms) {
		
		this.uniforms[ name ] = uniforms[ name ];
	
	}
	
};

THREE.NodeMaterial.prototype.createUniform = function( value, type, needsUpdate ) {
	
	var index = this.uniformList.length;
	
	var uniform = {
		type : type,
		value : value,
		needsUpdate : needsUpdate,
		name : 'nVu' + index
	};
	
	this.uniformList.push(uniform);
	
	return uniform;
	
};

THREE.NodeMaterial.prototype.getVar = function( name ) {
		
	return this.variables[ name ] || this.uniforms[ name ];
	
};

THREE.NodeMaterial.prototype.getVertexTemp = function( uuid, type ) {
	
	if (!this.vertexTemps[ uuid ]) {
		
		var index = this.vertexTemps.length,
			name = 'nVt' + index;
			data = { name : name, type : type };
		
		this.vertexTemps.push( data );
		this.vertexTemps[uuid] = data;
		
	}
	
	return this.vertexTemps[uuid];
	
};

THREE.NodeMaterial.prototype.getFragmentTemp = function( uuid, type ) {
	
	if (!this.fragmentTemps[ uuid ]) {
		
		var index = this.fragmentTemps.length,
			name = 'nVt' + index;
			data = { name : name, type : type };
		
		this.fragmentTemps.push( data );
		this.fragmentTemps[uuid] = data;
		
	}
	
	return this.fragmentTemps[uuid];
	
};

THREE.NodeMaterial.prototype.addVertexPars = function( code ) {

	this.vertexPars += code + '\n';

};

THREE.NodeMaterial.prototype.addFragmentPars = function( code ) {

	this.fragmentPars += code + '\n';

};

THREE.NodeMaterial.prototype.addVertexCode = function( code ) {

	this.vertexCode += code + '\n';

};

THREE.NodeMaterial.prototype.addFragmentCode = function( code ) {

	this.fragmentCode += code + '\n';

};

THREE.NodeMaterial.prototype.getCodePars = function( pars, prefix ) {

	prefix = prefix || '';

	var code = '';
	
	for (var i = 0, l = pars.length; i < l; ++i) {
		
		var type = THREE.NodeMaterial.Type[ pars[i].type ];

		code += prefix + ' ' + type + ' ' + pars[i].name + ';\n';
	}

	return code;

};

THREE.NodeMaterial.prototype.getVertexUniform = function( value, type, needsUpdate ) {

	var uniform = this.createUniform( value, type, needsUpdate );
	
	this.vertexUniform.push(uniform);
	this.vertexUniform[uniform.name] = uniform;
	
	this.uniforms[ uniform.name ] = uniform;
	
	return uniform;

};

THREE.NodeMaterial.prototype.getFragmentUniform = function( value, type, needsUpdate ) {

	var uniform = this.createUniform( value, type, needsUpdate );
	
	this.fragmentUniform.push(uniform);
	this.fragmentUniform[uniform.name] = uniform;
	
	this.uniforms[ uniform.name ] = uniform;
	
	return uniform;

};

THREE.NodeMaterial.prototype.getNodeData = function( uuid ) {

	return this.nodeData[uuid] = this.nodeData[uuid] || {};

};

// ------------------------------------------------------------

THREE.NodePhongMaterial = function() {
	
	this.phong = new THREE.NodePhong();
	
	THREE.NodeMaterial.call( this, this.phong, this.phong );
	
};

THREE.NodePhongMaterial.prototype = Object.create( THREE.NodeMaterial.prototype );
THREE.NodePhongMaterial.prototype.constructor = THREE.NodePhongMaterial;

THREE.NodeMaterial.Shortcuts( THREE.NodePhongMaterial.prototype, 'phong', 
[ 'color',  'alpha', 'specular', 'shininess', 'normal', 'emissive', 'ambient', 'shadow', 'light', 'transform', 'env' ] );

// ------------------------------------------------------------

THREE.Node = function( type ) {
	
	this.uuid = THREE.Math.generateUUID();
	this.allow = {};
	
	this.type = type;
	
};

THREE.Node.prototype.build = function( material, shader, output, uuid ) {

	this.validShader( shader );
	
	var code = this.generate( material, shader, output, uuid );
	
	return code;
	
};

THREE.Node.prototype.format = function(code, from, to) {
	
	var format = (from + '=' + to).replace('c','v3');
	
	switch ( format ) {
		case 'v3=v4': return 'vec4(' + code + ',1)';
		
		case 'v4=f': return code + '.x';
		case 'v4=v2': return code + '.xy';
		case 'v4=v3': return code + '.xyz';
	}
	
	return code;

};

THREE.Node.prototype.validShader = function( shader ) {
	
	if (this.allow[shader] === false) {
		throw new Error( 'Shader ' + shader + ' is not compatible with this node.' );
	}
	
};

// ------------------------------------------------------------

THREE.NodeInput = function(type) {
	
	THREE.Node.call( this, type );
	
};

THREE.NodeInput.prototype = Object.create( THREE.Node.prototype );
THREE.NodeInput.prototype.constructor = THREE.NodeInput;

THREE.NodeInput.prototype.generate = function( material, shader, output, uuid, type ) {

	uuid = uuid || this.uuid;
	type = type || this.type;
	
	var data = material.getNodeData( uuid );
	
	if (shader == 'vertex') {
	
		if (!data.vertex) {
		
			data.vertex = material.getVertexUniform( this.value, type );
			
		}
		
		return this.format( data.vertex.name, type, output );
	}
	else {
		
		if (!data.fragment) { 
			
			data.fragment = material.getFragmentUniform( this.value, type );
			
		}
		
		return this.format( data.fragment.name, type, output );
	}

};

///----------------------------------------------------

THREE.NodePhong = function() {
	
	THREE.Node.call( this, 'phong' );
	
	this.color = new THREE.NodeColor( 0xEEEEEE );
	this.alpha = new THREE.NodeFloat( 1 );
	this.specular = new THREE.NodeColor( 0x111111 );
	this.shininess = new THREE.NodeFloat( 30 );
	this.env = new THREE.NodeEnvironment();
	
};

THREE.NodePhong.prototype = Object.create( THREE.Node.prototype );
THREE.NodePhong.prototype.constructor = THREE.NodePhong;

THREE.NodePhong.prototype.generate = function( material, shader ) {
	
	material.shadows = material.shadows !== undefined ? material.shadows : true;
	
	material.define( 'PHONG' );
	
	material.needsLight = true;
	
	if (shader == 'vertex') {
		
		var transform = this.transform ? this.transform.build( material, shader, 'v3' ) : undefined;
		
		material.mergeUniform( THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],
			{
				"envMap" : { type: "t", value: null },
				"flipEnvMap" : { type: "f", value: - 1 },
				"reflectivity" : { type: "f", value: 1.0 },
				"refractionRatio" : { type: "f", value: 0.98 }
			}

		] ) );
		
		material.addVertexPars( [
			"varying vec3 vViewPosition;",

			"#ifndef FLAT_SHADED",

				"varying vec3 vNormal;",

			"#endif",

			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_vertex" ]

		].join( "\n" ) );

		var output = [
			THREE.ShaderChunk[ "beginnormal_vertex" ],
			THREE.ShaderChunk[ "morphnormal_vertex" ],
			THREE.ShaderChunk[ "skinbase_vertex" ],
			THREE.ShaderChunk[ "skinnormal_vertex" ],
			THREE.ShaderChunk[ "defaultnormal_vertex" ],

			"#ifndef FLAT_SHADED", // Normal computed with derivatives when FLAT_SHADED

				"vNormal = normalize( transformedNormal );",

			"#endif",

			THREE.ShaderChunk[ "begin_vertex" ]
		];
		
		if ( transform ) output.push( "transformed = " + transform + ";" );
		
		output.push(
			THREE.ShaderChunk[ "morphtarget_vertex" ],
			THREE.ShaderChunk[ "skinning_vertex" ],
			THREE.ShaderChunk[ "project_vertex" ],
			THREE.ShaderChunk[ "logdepthbuf_vertex" ],

			"vViewPosition = - mvPosition.xyz;",

			THREE.ShaderChunk[ "worldpos_vertex" ],
			THREE.ShaderChunk[ "lights_phong_vertex" ],
			THREE.ShaderChunk[ "shadowmap_vertex" ]
		);
		
		code = output.join( "\n" );
	}
	else {
		
		var color = this.color.build( material, shader, 'v4' );
		var alpha = this.alpha.build( material, shader, 'f' );
		var specular = this.specular.build( material, shader, 'c' );
		var shininess = this.shininess.build( material, shader, 'f' );
		
		var env = this.env.input ? this.env.input.build( material, shader, 'c' ) : undefined;
		
		var shadow = this.shadow ? this.shadow.build( material, shader, 'c' ) : undefined;
		var light = this.light ? this.light.build( material, shader, 'c' ) : undefined;
		var emissive = this.emissive ? this.emissive.build( material, shader, 'c' ) : undefined;
		var ambient = this.ambient ? this.ambient.build( material, shader, 'c' ) : undefined;
		
		var normal = this.normal ? this.normal.build( material, shader, 'v3' ) : undefined;
		
		var containsShadow = shadow || material.shadows;
		
		material.addFragmentPars( [
			THREE.ShaderChunk[ "common" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "logdepthbuf_pars_fragment" ]
		].join( "\n" ) );
		
		var output = [
			"vec3 outgoingLight = vec3( 0.0 );",
			"vec4 diffuseColor = " + color + ";",
			"vec3 totalAmbientLight = ambientLightColor;",
			"vec3 specular = " + specular + ";",
			"float shininess = " + shininess + ";"
		];
		
		output.push( "vec3 shadowMask = vec3( 1.0 );" );
		
		output.push(
			THREE.ShaderChunk[ "logdepthbuf_fragment" ],
			THREE.ShaderChunk[ "alphatest_fragment" ]
		);
		
		output.push(
			"float specularStrength = 1.0;",
			THREE.ShaderChunk[ "normal_phong_fragment" ]
		);
		
		if (normal) output.push("normal = " + normal + ";");
		
		output.push( 
			THREE.ShaderChunk[ "hemilight_fragment" ],
			THREE.ShaderChunk[ "lights_phong_fragment" ] 
		);
		
		if (light) output.push( "totalDiffuseLight += " + light + ";" );
		
		if (ambient) output.push( "totalAmbientLight += " + ambient + ";" );
		
		output.push( THREE.ShaderChunk[ "shadowmap_fragment" ] );
		
		if (shadow) output.push( "shadowMask *= " + shadow + ";" );
		
		if (containsShadow) {
		
			output.push(
				"totalDiffuseLight *= shadowMask;",
				"totalSpecularLight *= shadowMask;"
			);
			
		}
		
		output.push(
			"#ifdef METAL",

			"outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) * specular + totalSpecularLight;",

			"#else",

			"outgoingLight += diffuseColor.rgb * ( totalDiffuseLight + totalAmbientLight ) + totalSpecularLight;",

			"#endif"
		);
		
		if (emissive) output.push( "outgoingLight += " + emissive + ";" );
		
		output.push( THREE.ShaderChunk[ "envmap_fragment" ] );
		
		if (this.env.input) output.push( "outgoingLight " + this.env.op + this.env.input + ";" );
		
		output.push(
		
			THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

			THREE.ShaderChunk[ "fog_fragment" ],

			"gl_FragColor = vec4( outgoingLight, diffuseColor.a * " + alpha + " );"
		);
		
		code = output.join( "\n" );
	
	}
	
	return code;

};

//--------------------------------------------------------

THREE.NodeGL = function( value ) {
	
	THREE.Node.call( this, 'gl' );
	
	this.value = value;
	
};

THREE.NodeGL.prototype = Object.create( THREE.Node.prototype );
THREE.NodeGL.prototype.constructor = THREE.NodeGL;

THREE.NodeGL.prototype.generate = function( material, shader ) {
	
	if (shader == 'vertex') {
		
		return 'gl_Position = ' + this.value.generate( material, shader, output ) + ';';
		
	}
	else {
		
		return 'gl_FragColor = ' + this.value.generate( material, shader, output ) + ';';
	
	}

};

//--------------------------------------------------------

THREE.NodeGLPosition = function() {
	
	THREE.Node.call( this );
	
};

THREE.NodeGLPosition.prototype = Object.create( THREE.Node.prototype );
THREE.NodeGLPosition.prototype.constructor = THREE.NodeGLPosition;

THREE.NodeGL.prototype.generate = function( material, shader ) {

	if (shader == 'vertex') {
	
		return '(projectionMatrix * modelViewMatrix * vec4( position, 1.0 ))';
		
	}
	else {
	
		return 'vPosition';
		
	}

};

//--------------------------------------------------------

THREE.NodeReference = function( name, type ) {
	
	THREE.Node.call( this, type );
	
	this.name = name;
	
};

THREE.NodeReference.prototype = Object.create( THREE.Node.prototype );
THREE.NodeReference.prototype.constructor = THREE.NodeReference;

THREE.NodeReference.prototype.generate = function( material, shader, output ) {
	
	var data = material.getVar( this.name );
	
	this.value = data.value;
	this.type = data.type
	
	return this.format( this.name, this.type, output );

};

//--------------------------------------------------------

THREE.NodeTemp = function( type ) {
	
	THREE.Node.call( this, type );
	
};

THREE.NodeTemp.prototype = Object.create( THREE.Node.prototype );
THREE.NodeTemp.prototype.constructor = THREE.NodeReference;

THREE.NodeTemp.prototype.build = function( material, shader, output, uuid ) {
	
	THREE.Node.prototype.build.call( this, material, shader, uuid );
	
	var name = this.getTemp( material, shader, uuid )
	
	if (name) {
	
		return this.format( name, this.type, output );
		
	}
	else {
			
		name = THREE.NodeTemp.prototype.generate.call( this, material, shader );
		
		var code = this.generate( material, shader, this.type, uuid );
	
		return this.format( '(' + name + '=' + code + ')', this.type, output );
	
	}
	
};

THREE.NodeTemp.prototype.getTemp = function( material, shader, uuid ) {
	
	uuid = uuid || this.uuid;
	
	if (shader == 'vertex' && material.vertexTemps[ uuid ]) return material.vertexTemps[ uuid ].name;
	else if (material.fragmentTemps[ uuid ]) return material.fragmentTemps[ uuid ].name;

};

THREE.NodeTemp.prototype.generate = function( material, shader, output, uuid ) {
	
	uuid = uuid || this.uuid;
	
	if (shader == 'vertex') return material.getVertexTemp( uuid, this.type ).name;
	else return material.getFragmentTemp( uuid, this.type ).name;

};

//--------------------------------------------------------

THREE.NodeUV = function( uv2 ) {
	
	this.uv2 = uv2 || false;
	
	THREE.NodeReference.call( this );
	
};

THREE.NodeUV.prototype = Object.create( THREE.NodeReference.prototype );
THREE.NodeUV.prototype.constructor = THREE.NodeUV;

THREE.NodeUV.prototype.generate = function( material, shader, output ) {
	
	material.needsUv = material.needsUv || !this.uv2;
	material.needsUv2 = material.needsUv2 || this.uv2;

	if (shader == 'vertex') this.name = this.uv2 ? 'uv2' : 'uv';
	else this.name = this.uv2 ? 'vUv2' : 'vUv';
	
	return THREE.NodeReference.prototype.generate.call( this, material, shader, output );

};

//--------------------------------------------------------

THREE.NodeTexture = function( value, uv ) {
	
	THREE.NodeTemp.call( this, 'v4' );
	
	this.value = value;
	this.uv = uv || new THREE.NodeUV();
	
};

THREE.NodeTexture.prototype = Object.create( THREE.NodeTemp.prototype );
THREE.NodeTexture.prototype.constructor = THREE.NodeTexture;

THREE.NodeTexture.prototype.generate = function( material, shader, output ) {

	var tex = THREE.NodeInput.prototype.generate.call( this, material, shader, output, this.value.uuid, 't' );
	var uv = this.uv.build( material, shader, 'v2' );
	//inputToLinear xyz

	return this.format( 'texture2D(' + tex + ',' + uv + ')', 'v4', output );

};

//--------------------------------------------------------

THREE.NodeReflectUVW = function() {
	
	THREE.NodeReference.call( this, 'reflectCoord' );
	
};

THREE.NodeReflectUVW.prototype = Object.create( THREE.NodeReference.prototype );
THREE.NodeReflectUVW.prototype.constructor = THREE.NodeReflectUVW;

THREE.NodeReflectUVW.prototype.generate = function( material, shader, output ) {
	
	var code = 'vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n' +
		'vec3 reflectCoord = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n';
	
	return THREE.NodeReference.prototype.generate.call( this, material, shader, output );

};

//--------------------------------------------------------

THREE.NodeRefractVector = function() {
	
	THREE.Node.call( this, 'refractCoord' );
	
};

THREE.NodeRefractVector.prototype = Object.create( THREE.Node.prototype );
THREE.NodeRefractVector.prototype.constructor = THREE.NodeRefractVector;

THREE.NodeReflectUVW.prototype.generate = function( material, shader, output ) {
	
	var code = 'vec3 vt0 = refract( cameraToVertex, worldNormal, refractionRatio );\n' +
		'vec3 refractCoord = vec3( flipEnvMap * refractVec.x, refractVec.yz );\n';
	
	return THREE.NodeReference.prototype.generate.call( this, material, shader, output );

};

//--------------------------------------------------------

THREE.NodeRefractUVW = function() {
	
	THREE.NodeReference.call( this, 'refractCoord' );
	
};

THREE.NodeRefractUVW.prototype = Object.create( THREE.NodeReference.prototype );
THREE.NodeRefractUVW.prototype.constructor = THREE.NodeRefractUVW;

THREE.NodeReflectUVW.prototype.generate = function( material, shader, output ) {
	
	var code = 'vec3 refractVec = refract( cameraToVertex, worldNormal, refractionRatio );\n' +
		'vec3 refractCoord = vec3( flipEnvMap * refractVec.x, refractVec.yz );\n';
	
	return THREE.NodeReference.prototype.generate.call( this, material, shader, output );

};

//---------------------------------------


THREE.NodeCube = function( value, offset ) {
	
	THREE.NodeInput.call( this, 'tc' );
	
	this.allow.vertex = false;
	
	this.value = value;
	this.offset = offset;
	
};

THREE.NodeCube.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeCube.prototype.constructor = THREE.NodeTexture;

THREE.NodeCube.prototype.generate = function( material, shader, output ) {
	
	var data = material.getNodeData( this.uuid );
	
	if (shader == 'fragment') {
	
		if (!data.initied) {
		
			material.addFragmentPars( [
				"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",
				
				// Transforming Normal Vectors with the Inverse Transformation
				"vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );",
				
				'#ifdef DOUBLE_SIDED',
				
					'float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );',
					
				'#else',
				
					'float flipNormal = 1.0;',
					
				'#endif'
				
			].join( "\n" ) );
			
			data.initied = true;
			
		}
		
		return this.format( 'perturbNormal2Arb(-vViewPosition,normal,' +
			this.value.build( material, shader, 'v3' ) + ',' +
			this.value.uv.build( material, shader, 'v2' ) + ',' +
			this.scale.build( material, shader, 'f' ) + ')', this.type, output );
	}

};

THREE.NodeCube.prototype.generate = function( material, shader, output ) {

	var tex = THREE.Node.prototype.generate.call( this, material, shader, output, this.value.uuid, 't' );
	
	return this.format( 'textureCube(' + tex + ',' + uv + ')', 'v4', output );

};

//-----------------------------------------------

THREE.NodeNormal = function() {
	
	THREE.NodeReference.call( this );
	
};

THREE.NodeNormal.prototype = Object.create( THREE.NodeReference.prototype );
THREE.NodeNormal.prototype.constructor = THREE.NodeNormal;

THREE.NodeNormal.prototype.generate = function( material, shader, output ) {
	
	if (shader == 'vertex') this.name = 'normal';
	else this.name = 'vNormal';
	
	return THREE.NodeReference.prototype.generate.call( this, material, shader, output );

};

//-----------------------------------------------

THREE.NodeTransform = function( value, scale ) {
	
	THREE.NodeReference.call( this, 'transformed' );
	
	this.allow.fragment = false;
	
};

THREE.NodeTransform.prototype = Object.create( THREE.NodeReference.prototype );
THREE.NodeTransform.prototype.constructor = THREE.NodeTransform;

//--------------------------------------------------------

THREE.NodeNormalMap = function( value, scale ) {
	
	THREE.Node.call( this, 'v3' );
	
	this.allow.vertex = false;
	
	this.value = value;
	this.scale = scale || new THREE.NodeFloat(1);
	
};

THREE.NodeNormalMap.prototype = Object.create( THREE.Node.prototype );
THREE.NodeNormalMap.prototype.constructor = THREE.NodeNormalMap;

THREE.NodeNormalMap.prototype.generate = function( material, shader, output ) {
	
	var data = material.getNodeData( this.uuid );
	
	if (shader == 'fragment') {
	
		if (!data.initied) {
		
			material.extension('GL_OES_standard_derivatives');
		
			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html
			
			material.addFragmentPars( [
				"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 map, vec2 mUv, float scale ) {",
					"vec3 q0 = dFdx( eye_pos.xyz );",
					"vec3 q1 = dFdy( eye_pos.xyz );",
					"vec2 st0 = dFdx( mUv.st );",
					"vec2 st1 = dFdy( mUv.st );",
					"vec3 S = normalize( q0 * st1.t - q1 * st0.t );",
					"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
					"vec3 N = normalize( surf_norm );",
					"vec3 mapN = map * 2.0 - 1.0;",
					"mapN.xy = scale * mapN.xy;",
					"mat3 tsn = mat3( S, T, N );",
					"return normalize( tsn * mapN );",
				"}"
			].join( "\n" ) );
			
			data.initied = true;
			
		}
		
		return this.format( 'perturbNormal2Arb(-vViewPosition,normal,' +
			this.value.build( material, shader, 'v3' ) + ',' +
			this.value.uv.build( material, shader, 'v2' ) + ',' +
			this.scale.build( material, shader, 'f' ) + ')', this.type, output );
	}

};

//--------------------------------------------------------

THREE.NodeColor = function( color ) {
	
	THREE.NodeInput.call( this, 'c' );
	
	this.value = new THREE.Color( color || 0 );
	
};

THREE.NodeColor.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeColor.prototype.constructor = THREE.NodeColor;

THREE.NodeMaterial.Shortcuts( THREE.NodeColor.prototype, 'value', [ 'r', 'g', 'b' ] );

//--

THREE.NodeFloat = function( value ) {
	
	THREE.NodeInput.call( this, 'fv1' );
	
	this.value = [ value || 0 ];
	
};

THREE.NodeFloat.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeFloat.prototype.constructor = THREE.NodeFloat;

Object.defineProperties( THREE.NodeFloat.prototype, {
	number: {
		get: function () { return this.value[0]; },
		set: function ( val ) { this.value[0] = val; }
	}
});

//--

THREE.NodeVector2 = function( x, y ) {
	
	THREE.NodeInput.call( this, 'v2' );
	
	this.value = new THREE.Vector2( x, y );
	
};

THREE.NodeVector2.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeVector2.prototype.constructor = THREE.NodeVector2;

THREE.NodeMaterial.Shortcuts( THREE.NodeVector2.prototype, 'value', [ 'x', 'y' ] );

//--

THREE.NodeVector3 = function( x, y, z ) {
	
	THREE.NodeInput.call( this, 'v3' );
	
	this.type = 'v3';
	this.value = new THREE.Vector3( x, y, z );
	
};

THREE.NodeVector3.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeVector3.prototype.constructor = THREE.NodeVector3;

THREE.NodeMaterial.Shortcuts( THREE.NodeVector3.prototype, 'value', [ 'x', 'y', 'z' ] );

//--

THREE.NodeVector4 = function( x, y, z, w ) {
	
	THREE.Node.call( this, 'v4' );
	
	this.value = new THREE.Vector4( x, y, z, w );
	
};

THREE.NodeVector4.prototype = Object.create( THREE.Node.prototype );
THREE.NodeVector4.prototype.constructor = THREE.NodeVector4;

THREE.NodeMaterial.Shortcuts( THREE.NodeVector4.prototype, 'value', [ 'x', 'y', 'z', 'w' ] );

//-------------------------

THREE.NodeOperator = function( op, a, b, cache ) {
	
	cache = cache !== undefined ? cache : true;
	
	THREE.NodeInput.call( this, 'op' );
	
	this.op = op || '+';
	
	this.a = a;
	this.b = b;
	
	this.cache = cache;
	
};

THREE.NodeOperator.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeOperator.prototype.constructor = THREE.NodeOperator;

THREE.NodeOperator.prototype.generate = function( material, shader, output ) {
	
	var a = this.a.build( material, shader, output );
	var b = this.b.build( material, shader, output );
	
	return this.format( '(' + a + this.op + b + ')', this.a.type, output);

};

//-------------------------

THREE.NodeEnvironment = function( input, op ) {
	
	THREE.NodeInput.call( this, 'op' );
	
	this.op = op || '+';
	
	this.input = input;
	
};

THREE.NodeEnvironment.prototype = Object.create( THREE.NodeInput.prototype );
THREE.NodeEnvironment.prototype.constructor = THREE.NodeEnvironment;

THREE.NodeEnvironment.prototype.generate = function( material, shader, output ) {
	
	material.define( 'USE_ENVMAP' );
	
	return this.input.generate( material, shader, output );

};

//--

/*


THREE.NodeConditional = function() {
	
	THREE.Node.call( this );
	
	this.conditional = null;
	this.else = null;
	
	this.value = null;
	
	this.generate = function( material, shader, output ) {
		
		var code = 'if(' + this.conditional.generate( material, shader, output ) + '){\n';
		
		code += this.value.generate( material, shader, output ) + ';\n}';
		
		if (this.else instanceof THREE.NodeConditional) {
			
			code += 'else ' + this.else.generate( material, shader, output );
		
		}
		else if (this.else) {
			
			code += 'else{\n' + this.else.generate( material, shader, output ) + ';\n}';
			
		}
		
		return a + this.value + b;
		
	};
	
};*/



			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var camera, scene, renderer, objects;
			var particleLight;
			var nodemat, color, uv_anm;
			
			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 20, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.set( 0, 200, 0 );

				scene = new THREE.Scene();

				// Materials

				var imgTexture2 = THREE.ImageUtils.loadTexture( "textures/moon_1024.jpg" );
				imgTexture2.wrapS = imgTexture2.wrapT = THREE.RepeatWrapping;
				imgTexture2.anisotropy = 16;

				var imgTexture = THREE.ImageUtils.loadTexture( "textures/lavatile.jpg" );
				imgTexture.repeat.set( 4, 2 );
				imgTexture.wrapS = imgTexture.wrapT = THREE.RepeatWrapping;
				imgTexture.anisotropy = 16;

				var nMap = THREE.ImageUtils.loadTexture( "textures/waternormals.jpg" );
				
				var shininess = 50, specular = 0x333333, bumpScale = 1, shading = THREE.SmoothShading;

				var materials = [];

				/*
				var op = new THREE.NodeOperator( '*' );
				op.a = new THREE.NodeFloat(3);
				op.b = new THREE.NodeColor( 0x1100FF );
				*/
				
				nodemat = new THREE.NodePhongMaterial();				
				//nodemat.diffuse.r = 1;
				//nodemat.diffuse.b = 1;
				
				uv_anm = new THREE.NodeFloat(0);
				
				var uv = new THREE.NodeOperator( '+', new THREE.NodeUV(), uv_anm);
				var t = new THREE.NodeTexture( imgTexture, uv );
				var t2 = new THREE.NodeTexture( imgTexture );
				
				var albedo2 = new THREE.NodeOperator( '*', t, t2);
				
				var tt = new THREE.NodeOperator( 
					'*', 
					new THREE.NodeNormal(), 
					t
				);
				
				var ttscale = new THREE.NodeOperator( 
					'*', 
					tt, 
					new THREE.NodeFloat(20)
				);
				
				// albedo
				nodemat.color = t;
				
				// displace example
				nodemat.transform = new THREE.NodeOperator( 
					'+', 
					new THREE.NodeTransform(), 
					ttscale
				);
				
				//nodemat.color.value.setHex( 0 );
				//nodemat.emissive = new THREE.NodeTexture( nMap );
				//nodemat.ambient = albedo2;
				//nodemat.alpha = new THREE.NodeTexture( imgTexture );
				//nodemat.shadow = new THREE.NodeColor( 0 );
				nodemat.normal = new THREE.NodeNormalMap( new THREE.NodeTexture( nMap ) );
				//nodemat.env.input = new THREE.NodeTexture( imgTexture );
				//nodemat.alpha.number = .3
				nodemat.transparent = true;
				nodemat.build();
				
				//nodemat.generate();
				//material.update( delta );
				
				/*material.defines.USE_MAP = true;
				
				//material.uniforms.useMap = {type: 'f', value: 1};
				
				material.uniforms.map.value = imgTexture;
				
				material.uniforms.diffuse.value = new THREE.Color( 0xffffff );
				
				material.uniforms.specular.value = new THREE.Color( 0x111111 );
				material.uniforms.shininess.value = Math.max( 30, 1e-4 );*/
				
				
				materials.push( nodemat );
				
				nodemat = new THREE.NodePhongMaterial();
				nodemat.color = albedo2;
				nodemat.build();
				
				materials.push( nodemat );
				
				nodemat = new THREE.NodePhongMaterial();
				nodemat.color = new THREE.NodeColor( 0 );
				nodemat.emissive = albedo2;
				nodemat.alpha = new THREE.NodeTexture( imgTexture );
				nodemat.transparent = true;
				nodemat.build();
				
				materials.push( nodemat );
				
				// Spheres geometry

				var geometry_smooth = new THREE.SphereBufferGeometry( 70, 64, 32 );
				var geometry_flat = new THREE.SphereBufferGeometry( 70, 64, 32 );

				objects = [];

				var sphere, geometry, material;

				for ( var i = 0, l = materials.length; i < l; i ++ ) {

					material = materials[ i ];

					geometry = material.shading == THREE.FlatShading ? geometry_flat : geometry_smooth;

					sphere = new THREE.Mesh( geometry, material );

					sphere.position.x = ( i % 4 ) * 200 - 200;
					sphere.position.z = Math.floor( i / 4 ) * 200 - 200;

					objects.push( sphere );

					scene.add( sphere );

				}

				particleLight = new THREE.Mesh( new THREE.SphereBufferGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( { color: 0xffffff } ) );
				//scene.add( particleLight );

				// Lights

				scene.add( new THREE.AmbientLight( 0x444444 ) );

				var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
				directionalLight.position.set( 1, 1, 1 ).normalize();
				scene.add( directionalLight );

				var pointLight = new THREE.PointLight( 0xffffff, 2, 800 );
				particleLight.add( pointLight );

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setClearColor( 0x0a0a0a );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = true;

				container.appendChild( renderer.domElement );

				renderer.gammaInput = true;
				renderer.gammaOutput = true;

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';

				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				//console.log( 1, nodemat.fragment.value);
				
				render();
				stats.update();

			}

			function render() {

				var timer = Date.now() * 0.00025;

				uv_anm.number += .005;
				
				camera.position.x = Math.cos( timer ) * 800;
				camera.position.z = Math.sin( timer ) * 800;

				camera.lookAt( scene.position );

				for ( var i = 0, l = objects.length; i < l; i ++ ) {

					var object = objects[ i ];

					object.rotation.y += 0.005;

				}

				particleLight.position.x = Math.sin( timer * 7 ) * 300;
				particleLight.position.y = Math.cos( timer * 5 ) * 400;
				particleLight.position.z = Math.cos( timer * 3 ) * 300;

				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
