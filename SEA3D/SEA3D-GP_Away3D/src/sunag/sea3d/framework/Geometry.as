package sunag.sea3d.framework
{
	import away3d.arcane;
	import away3d.core.base.Geometry;
	import away3d.core.base.SkinnedSubGeometry;
	import away3d.core.base.SubGeometry;
	
	import sunag.sea3dgp;
	import sunag.sea3d.objects.SEAGeometryBase;
	import sunag.sea3d.objects.SEAObject;

	use namespace sea3dgp;
	
	public class Geometry extends Asset
	{
		private static const TYPE:String = 'Geometry/';
		
		sea3dgp static const NULL:away3d.core.base.Geometry = new away3d.core.base.Geometry();
		
		public static function getAsset(name:String):Geometry
		{
			return Asset.getAsset(TYPE+name) as Geometry;
		}
		
		sea3dgp var scope:away3d.core.base.Geometry;
		
		sea3dgp var numVertex:int = 0;
		sea3dgp var jointPerVertex:int = 0;
		
		public function Geometry()
		{
			super(TYPE);
		}
		
		override sea3dgp function load(sea:SEAObject):void
		{
			super.load(sea);
			
			//
			//	GEOMETRY
			//
			
			var geo:SEAGeometryBase = sea as SEAGeometryBase;
									
			scope = new away3d.core.base.Geometry();			
			
			if (!geo.isBig)
			{
				for each(var index:Vector.<uint> in geo.indexes)			
				{
					// Skeleton
					if (geo.jointPerVertex > 0)
					{
						var skinSubGeo:SkinnedSubGeometry = new SkinnedSubGeometry(geo.jointPerVertex);
						
						skinSubGeo.updateIndexData(index);					
						skinSubGeo.fromVectors
							(
								geo.vertex, 
								geo.uv && geo.uv.length > 0 ? geo.uv[0] : null, 
								geo.normal, 
								geo.tangent, 
								geo.uv && geo.uv.length > 1 ? geo.uv[1] : null
							);						
						
						skinSubGeo.arcane::updateJointIndexData(geo.joint);
						skinSubGeo.arcane::updateJointWeightsData(geo.weight);					
						
						scope.addSubGeometry(skinSubGeo);
					}	
					else
					{
						var stdSubGeo:SubGeometry = new SubGeometry();
						
						stdSubGeo.updateIndexData(index);
						
						stdSubGeo.updateVertexData(geo.vertex);
						
						if (geo.uv) 
						{
							stdSubGeo.updateUVData(geo.uv[0]);
							if (geo.uv.length > 1) stdSubGeo.updateSecondaryUVData(geo.uv[1]);
						}
						else stdSubGeo.autoGenerateDummyUVs = true;
						
						if (geo.normal) stdSubGeo.updateVertexNormalData(geo.normal);
						else stdSubGeo.autoDeriveVertexNormals = true;
						
						if (geo.tangent) stdSubGeo.updateVertexTangentData(geo.tangent);
						else stdSubGeo.autoDeriveVertexTangents = true;
						
						scope.addSubGeometry(stdSubGeo);					
					}
				}
			}		
			
			numVertex = geo.numVertex;
			jointPerVertex = geo.jointPerVertex;
		}
	}
}